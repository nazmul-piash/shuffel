<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Multiplayer Token Game</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter for general text, Caveat for handwriting -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Caveat:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); /* Softer shadow */
            padding: 2.5rem; /* More padding */
            max-width: 600px;
            width: 100%;
            text-align: center;
        }
        .btn-primary {
            background-color: #4f46e5; /* Indigo */
            color: white;
            padding: 0.8rem 1.8rem;
            border-radius: 0.75rem; /* Rounded corners for buttons */
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out;
            box-shadow: 0 4px 10px rgba(79, 70, 229, 0.3); /* Button shadow */
        }
        .btn-primary:hover {
            background-color: #4338ca; /* Darker indigo on hover */
            transform: translateY(-2px); /* Slight lift effect */
            box-shadow: 0 6px 15px rgba(79, 70, 229, 0.4);
        }
        .btn-primary:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(79, 70, 229, 0.3);
        }
        .btn-secondary {
            background-color: #6b7280; /* Gray */
            color: white;
            padding: 0.8rem 1.8rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out;
            box-shadow: 0 4px 10px rgba(107, 114, 128, 0.3);
        }
        .btn-secondary:hover {
            background-color: #4b5563; /* Darker gray on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(107, 114, 128, 0.4);
        }
        .btn-secondary:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(107, 114, 128, 0.3);
        }
        .input-field {
            border: 1px solid #d1d5db; /* Light gray border */
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            width: 100%;
            font-size: 1rem;
            color: #374151; /* Dark gray text */
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .input-field:focus {
            outline: none;
            border-color: #6366f1; /* Focus color */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); /* Focus ring */
        }
        .handwriting-font {
            font-family: 'Caveat', cursive;
            font-size: 1.5rem; /* Larger for readability */
        }
        .message-box {
            background-color: #d1fae5; /* Light green for success */
            border: 1px solid #34d399; /* Green border */
            color: #065f46; /* Dark green text */
            padding: 1rem;
            border-radius: 0.75rem;
            margin-top: 1.5rem;
            font-weight: 600;
            display: none; /* Hidden by default */
        }
        .message-box.error {
            background-color: #fee2e2; /* Light red for error */
            border-color: #ef4444; /* Red border */
            color: #991b1b; /* Dark red text */
        }
        /* Style for individual token input fields */
        .token-text-input {
            border: 1px solid #c7d2fe;
            border-radius: 0.75rem;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            width: 100%;
            box-sizing: border-box;
            resize: vertical; /* Allow vertical resizing */
            min-height: 50px; /* Minimum height for textarea */
        }
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #4f46e5;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .copy-button {
            background-color: #10b981; /* Emerald green */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: background-color 0.2s ease-in-out;
            margin-left: 10px;
        }
        .copy-button:hover {
            background-color: #059669; /* Darker emerald */
        }
        .player-indicator {
            padding: 0.5rem 1rem;
            border-radius: 0.75rem;
            font-weight: 700;
            color: #4f46e5;
            background-color: #e0e7ff;
            border: 2px solid transparent;
            transition: all 0.3s ease-in-out;
        }
        .player-indicator.active {
            border-color: #4f46e5;
            background-color: #c7d2fe;
            box-shadow: 0 4px 10px rgba(79, 70, 229, 0.2);
        }
        .token-card-display {
            background-color: #a5b4fc; /* Slightly darker indigo for folded state */
            color: #ffffff;
            font-size: 1.25rem; /* Larger font for '?' */
            font-weight: 700;
            width: 100px; /* Fixed width for consistent cards */
            height: 100px; /* Fixed height for consistent cards */
            border-radius: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0.5rem;
            box-shadow: 0 4px 10px rgba(79, 70, 229, 0.2);
            transition: all 0.3s ease-in-out;
            cursor: pointer;
            flex-shrink: 0; /* Prevent shrinking in flex container */
            position: relative; /* For overlay */
        }
        .token-card-display:hover:not(.revealed):not(.picked) {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px rgba(79, 70, 229, 0.3);
        }
        .token-card-display.revealed {
            background-color: #d1fae5; /* Light green for revealed */
            color: #065f46;
            cursor: default;
            box-shadow: 0 4px 10px rgba(52, 211, 153, 0.3);
            border: 2px solid #34d399;
        }
        .token-card-display.picked {
            background-color: #fca5a5; /* Light red for picked by other */
            color: #991b1b;
            cursor: default;
            box-shadow: 0 4px 10px rgba(239, 68, 68, 0.3);
            border: 2px solid #ef4444;
        }
        .token-card-display.disabled {
            opacity: 0.7;
            cursor: default;
            pointer-events: none; /* Disable clicks */
        }
        .game-over-message {
            color: #ef4444; /* Red for game over */
            font-size: 1.8rem;
            font-weight: 700;
            margin-top: 1.5rem;
        }
        .token-content-text {
            font-family: 'Caveat', cursive;
            font-size: 1.2rem;
            padding: 0.5rem;
            word-break: break-all;
            text-align: center;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-5">
    <div class="container bg-white p-10 rounded-3xl shadow-xl flex flex-col items-center">
        <h1 class="text-4xl font-extrabold text-gray-800 mb-6">The Multiplayer Token Game</h1>
        <!-- User ID display, initially hidden -->
        <p id="userIdDisplay" class="text-sm text-gray-500 mb-4 break-all hidden">Your User ID: <span id="currentUserId" class="font-mono">Loading...</span></p>

        <!-- Player Indicators -->
        <div class="flex justify-center gap-4 mb-6 w-full">
            <div id="player1Indicator" class="player-indicator">Player 1</div>
            <div id="player2Indicator" class="player-indicator">Player 2</div>
        </div>

        <!-- Username Input Phase -->
        <div id="username-input-phase" class="w-full">
            <p class="text-lg text-gray-600 mb-4">Enter your username to begin:</p>
            <input type="text" id="usernameInput" class="input-field mb-4" placeholder="Your Username (e.g., PlayerOne)">
            <button id="continueBtn" class="btn-primary w-full">Continue</button>
        </div>

        <!-- Initial Phase: Create or Join Game -->
        <div id="initial-phase" class="w-full hidden">
            <p class="text-lg text-gray-600 mb-4">Welcome, <span id="displayUsername" class="font-semibold text-indigo-700"></span>! What would you like to do?</p>
            <button id="createGameBtn" class="btn-primary w-full mb-4">Create New Game</button>
            <div class="flex items-center justify-center my-4">
                <span class="text-gray-500">OR</span>
            </div>
            <input type="text" id="gameIdInput" class="input-field mb-4" placeholder="Enter Game ID to Join">
            <button id="joinGameBtn" class="btn-secondary w-full">Join Game</button>
        </div>

        <!-- Waiting Phase (for Player 1 after creating game, or Player 2 after joining) -->
        <div id="waiting-phase" class="w-full hidden">
            <p class="text-lg text-gray-600 mb-4" id="waitingMessage">Waiting for other player...</p>
            <!-- Invite link container is now removed, only Game ID will be shown -->
            <div class="loading-spinner"></div>
        </div>

        <!-- Phase 1: Specify Number of Tokens (Player 1 only) -->
        <div id="number-input-phase" class="w-full hidden">
            <p class="text-lg text-gray-600 mb-4">Player 1: How many tokens do you want?</p>
            <input type="number" id="numTokensInput" class="input-field mb-4" min="2" value="4" placeholder="Enter number of tokens (min 2)">
            <button id="generateTokenFieldsBtn" class="btn-primary w-full mb-6">Generate Token Fields</button>
        </div>

        <!-- Phase 2: Enter Token Content (Player 1 only) -->
        <div id="content-input-phase" class="w-full hidden">
            <p class="text-lg text-gray-600 mb-4">Player 1: Enter text for each token.</p>
            <div id="dynamicTokenInputs" class="flex flex-col gap-3 mb-6">
                <!-- Dynamic token input fields will be appended here -->
            </div>
            <button id="confirmTokensBtn" class="btn-primary w-full mb-6">Confirm Tokens & Shuffle</button>
        </div>

        <!-- Phase 3: Pick Token (Player 2 only) -->
        <div id="game-phase" class="w-full hidden">
            <p class="text-lg text-gray-600 mb-6" id="gamePhaseMessage">Player 2: Pick a token!</p>

            <!-- Display area for individual tokens -->
            <div id="tokenDisplayArea" class="flex flex-wrap justify-center gap-4 mb-6">
                <!-- Token cards will be rendered here -->
            </div>

            <div id="revealedTokenContainer" class="message-box hidden">
                <p class="text-xl font-bold mb-2">You got:</p>
                <p id="revealedTokenContent" class="text-2xl text-indigo-700 font-extrabold break-words handwriting-font"></p>
            </div>

            <p id="gameOverMessage" class="game-over-message hidden">Game Over! All tokens picked.</p>

            <!-- New "Play Again" button -->
            <button id="playAgainBtn" class="btn-primary w-full mb-4 hidden">Play Again</button>
            <!-- Original "Reset Game" button for full reset -->
            <button id="resetGameBtn" class="btn-secondary w-full mt-4">Reset Game</button>
        </div>

        <!-- Message Box for Feedback -->
        <div id="messageBox" class="message-box w-full hidden"></div>
    </div>

    <script type="module">
        // Firebase imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, arrayUnion, arrayRemove, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js";

        // Firebase configuration from your Firebase project (provided by user)
        const firebaseConfig = {
            apiKey: "AIzaSyCz5NXK-P5FK-c8yh8oph2kgODB_cBoi1g",
            authDomain: "we-shuffle.firebaseapp.com",
            projectId: "we-shuffle",
            storageBucket: "we-shuffle.firebasestorage.app",
            messagingSenderId: "94132103590",
            appId: "1:94132103590:web:70f7ae80fe8c96dc664767",
            measurementId: "G-RGEF60JEKN"
        };

        // Derived from firebaseConfig
        const appId = firebaseConfig.appId;
        const initialAuthToken = null; // Not needed for anonymous sign-in in this context

        // Firebase App and Services
        let app, db, auth;
        let userId = null;
        let userName = null; // New global variable for username
        let gameId = null;
        let unsubscribeFromGame = null; // To store the Firestore snapshot listener unsubscribe function

        // Game state variables
        // Tokens will now be objects: { id: string, content: string, revealed: boolean, pickedBy: string|null }
        let tokens = [];
        let revealedToken = null; // Content of the last revealed token
        let numberOfTokensToGenerate = 0;
        let playerRole = null; // 'player1' or 'player2'
        // 'players' will now be an array of objects: [{id: userId, name: userName, role: 'player1'}, ...]
        let players = [];


        // Get DOM elements
        const usernameInputPhase = document.getElementById('username-input-phase');
        const usernameInput = document.getElementById('usernameInput');
        const continueBtn = document.getElementById('continueBtn');
        const displayUsername = document.getElementById('displayUsername'); // Span to show username in initial-phase

        const userIdDisplay = document.getElementById('userIdDisplay'); // Now refers to the container p tag
        const currentUserIdSpan = document.getElementById('currentUserId'); // The span inside userIdDisplay
        const player1Indicator = document.getElementById('player1Indicator');
        const player2Indicator = document.getElementById('player2Indicator');
        const initialPhase = document.getElementById('initial-phase');
        const createGameBtn = document.getElementById('createGameBtn');
        const gameIdInput = document.getElementById('gameIdInput');
        const joinGameBtn = document.getElementById('joinGameBtn');
        const waitingPhase = document.getElementById('waiting-phase');
        const waitingMessage = document.getElementById('waitingMessage');
        const numberInputPhase = document.getElementById('number-input-phase');
        const numTokensInput = document.getElementById('numTokensInput');
        const generateTokenFieldsBtn = document.getElementById('generateTokenFieldsBtn');
        const contentInputPhase = document.getElementById('content-input-phase');
        const confirmTokensBtn = document.getElementById('confirmTokensBtn');
        const dynamicTokenInputs = document.getElementById('dynamicTokenInputs');
        const gamePhase = document.getElementById('game-phase');
        const gamePhaseMessage = document.getElementById('gamePhaseMessage');
        const tokenDisplayArea = document.getElementById('tokenDisplayArea');
        const pickTokenBtn = document.getElementById('pickTokenBtn');
        const revealedTokenContainer = document.getElementById('revealedTokenContainer');
        const revealedTokenContent = document.getElementById('revealedTokenContent');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const resetGameBtn = document.getElementById('resetGameBtn');
        const messageBox = document.getElementById('messageBox');

        /**
         * Displays a message in the message box.
         * @param {string} message - The message to display.
         * @param {boolean} isError - True if it's an error message, false otherwise.
         */
        function showMessage(message, isError = false) {
            messageBox.textContent = message;
            messageBox.classList.remove('hidden', 'error');
            if (isError) {
                messageBox.classList.add('error');
            }
            messageBox.classList.remove('hidden');
            // Hide message after 3 seconds
            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 3000);
        }

        /**
         * Hides all game phases and shows only the specified one.
         * @param {HTMLElement} phaseToShow - The phase element to display.
         */
        function showPhase(phaseToShow) {
            usernameInputPhase.classList.add('hidden'); // Ensure username phase is hidden
            initialPhase.classList.add('hidden');
            waitingPhase.classList.add('hidden');
            numberInputPhase.classList.add('hidden');
            contentInputPhase.classList.add('hidden');
            gamePhase.classList.add('hidden');
            playAgainBtn.classList.add('hidden');
            gameOverMessage.classList.add('hidden');
            revealedTokenContainer.classList.add('hidden');
            phaseToShow.classList.remove('hidden');
        }

        /**
         * Updates the player indicators to show whose turn/role it is.
         * Now uses player names.
         * @param {string} activePlayerRole - 'player1', 'player2', or null/undefined for no active player.
         */
        function updatePlayerIndicators(activePlayerRole) {
            player1Indicator.classList.remove('active');
            player2Indicator.classList.remove('active');

            const p1 = players.find(p => p.role === 'player1');
            const p2 = players.find(p => p.role === 'player2');

            player1Indicator.textContent = p1 ? `Player 1 (${p1.name})` : 'Player 1';
            player2Indicator.textContent = p2 ? `Player 2 (${p2.name})` : 'Player 2';

            if (activePlayerRole === 'player1') {
                player1Indicator.classList.add('active');
            } else if (activePlayerRole === 'player2') {
                player2Indicator.classList.add('active');
            }
        }

        /**
         * Initializes Firebase and authenticates the user.
         * Now called after username is entered.
         */
        async function initializeFirebaseAndAuthenticate() {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // IMPORTANT: If you are seeing "auth/configuration-not-found" error,
                // it means Firebase Authentication (Anonymous provider) is not enabled in your project.
                // Go to Firebase Console -> Authentication -> Get started, and enable the "Anonymous" provider.
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        currentUserIdSpan.textContent = userId;
                        console.log("Authenticated with user ID:", userId);

                        displayUsername.textContent = userName; // Set username in initial phase
                        showPhase(initialPhase); // Show initial options after username and auth

                        const urlParams = new URLSearchParams(window.location.search);
                        const urlGameId = urlParams.get('gameId');
                        if (urlGameId) {
                            gameIdInput.value = urlGameId;
                            joinGame(); // Attempt to auto-join if gameId in URL
                        } else {
                            updatePlayerIndicators(null);
                        }
                    } else {
                        currentUserIdSpan.textContent = 'Not Authenticated';
                        console.log("No user is signed in.");
                        showMessage("Authentication failed. Please refresh.", true);
                    }
                });
            } catch (error) {
                console.error("Error initializing Firebase or authenticating:", error);
                showMessage("Failed to initialize game. Please try again later.", true);
            }
        }

        /**
         * Handles username input and proceeds to authentication.
         */
        function handleUsernameInput() {
            const inputName = usernameInput.value.trim();
            if (inputName.length < 2) {
                showMessage("Please enter a username (at least 2 characters).", true);
                return;
            }
            userName = inputName;
            initializeFirebaseAndAuthenticate(); // Proceed to Firebase auth after getting username
        }

        /**
         * Creates a new game session in Firestore.
         */
        async function createGame() {
            if (!userId || !userName) {
                showMessage("User not authenticated or username missing. Please wait.", true);
                return;
            }

            try {
                showPhase(waitingPhase);
                waitingMessage.textContent = "Creating game...";

                const gamesCollectionRef = collection(db, `artifacts/${appId}/public/data/games`);
                const newGameRef = doc(gamesCollectionRef);
                gameId = newGameRef.id;

                // Initialize players array with Player 1
                players = [{ id: userId, name: userName, role: 'player1' }];

                await setDoc(newGameRef, {
                    players: players, // Store players array
                    status: 'waiting_for_player2', // For now, still 2 players
                    tokens: [],
                    revealedToken: null,
                    createdAt: serverTimestamp(),
                    lastUpdated: serverTimestamp()
                });

                playerRole = 'player1';
                waitingMessage.textContent = `Game created! Share this Game ID with Player 2: ${gameId}`;
                showMessage("Game created successfully!");

                listenToGameChanges();

            } catch (error) {
                console.error("Error creating game:", error);
                showMessage("Failed to create game. Please try again.", true);
                showPhase(initialPhase);
            }
        }

        /**
         * Joins an existing game session.
         */
        async function joinGame() {
            if (!userId || !userName) {
                showMessage("User not authenticated or username missing. Please wait.", true);
                return;
            }

            const inputGameId = gameIdInput.value.trim();
            if (!inputGameId) {
                showMessage("Please enter a Game ID to join.", true);
                return;
            }

            try {
                showPhase(waitingPhase);
                waitingMessage.textContent = "Joining game...";

                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, inputGameId);
                const gameSnap = await getDoc(gameRef);

                if (!gameSnap.exists()) {
                    showMessage("Game not found. Please check the Game ID.", true);
                    showPhase(initialPhase);
                    return;
                }

                const gameData = gameSnap.data();

                // Check if already in game
                if (gameData.players && gameData.players.some(p => p.id === userId)) {
                    gameId = inputGameId;
                    playerRole = gameData.players.find(p => p.id === userId).role; // Determine role from existing data
                    players = gameData.players; // Sync local players array
                    showMessage(`Rejoined game ${gameId} as ${playerRole}.`);
                    listenToGameChanges();
                    return;
                }

                // For now, assume a 2-player game. Check if player2 slot is open.
                if (gameData.players.length >= 2) { // If there are already 2 players
                    showMessage("This game is already full.", true);
                    showPhase(initialPhase);
                    return;
                }

                // Add current user as Player 2
                playerRole = 'player2';
                await updateDoc(gameRef, {
                    players: arrayUnion({ id: userId, name: userName, role: 'player2' }),
                    status: 'ready_to_create_tokens',
                    lastUpdated: serverTimestamp()
                });

                gameId = inputGameId;
                waitingMessage.textContent = `Joined game ${gameId}! Waiting for Player 1 to create tokens...`;
                showMessage("Successfully joined game!");

                listenToGameChanges();

            } catch (error) {
                console.error("Error joining game:", error);
                showMessage("Failed to join game. Please try again.", true);
                showPhase(initialPhase);
            }
        }

        /**
         * Sets up a real-time listener for the current game document.
         */
        function listenToGameChanges() {
            if (unsubscribeFromGame) {
                unsubscribeFromGame();
            }

            if (!gameId) {
                console.error("Cannot listen to game changes: gameId is null.");
                return;
            }

            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            unsubscribeFromGame = onSnapshot(gameRef, (docSnap) => {
                if (docSnap.exists()) {
                    const gameData = docSnap.data();
                    players = gameData.players || []; // Update local players array
                    // Extract player1Id and player2Id for indicator display convenience
                    const p1 = players.find(p => p.role === 'player1');
                    const p2 = players.find(p => p.role === 'player2');
                    // Update global player1Id and player2Id for indicator function
                    player1Id = p1 ? p1.id : null;
                    player2Id = p2 ? p2.id : null;

                    console.log("Game state updated:", gameData);
                    updateUIBasedOnGameState(gameData);
                } else {
                    showMessage("Game ended or deleted. Resetting...", true);
                    resetGame();
                }
            }, (error) => {
                console.error("Error listening to game changes:", error);
                showMessage("Lost connection to game. Please reset.", true);
            });
        }

        /**
         * Updates the UI based on the current game state from Firestore.
         * @param {object} gameData - The current game data from Firestore.
         */
        function updateUIBasedOnGameState(gameData) {
            tokens = gameData.tokens || [];
            revealedToken = gameData.revealedToken;

            updatePlayerIndicators(playerRole); // Update indicators with names

            gameOverMessage.classList.add('hidden');
            revealedTokenContainer.classList.add('hidden');
            playAgainBtn.classList.add('hidden');

            renderTokenCards(tokens);

            const allTokensRevealed = tokens.length > 0 && tokens.every(token => token.revealed);

            // Player 1's flow
            if (playerRole === 'player1') {
                if (gameData.status === 'waiting_for_player2' && players.length < 2) {
                    showPhase(waitingPhase);
                    waitingMessage.textContent = `Game created! Share this Game ID with Player 2: ${gameId}`;
                } else if (gameData.status === 'ready_to_create_tokens' && players.length >= 2) {
                    showPhase(numberInputPhase);
                    showMessage("Player 2 has joined! Please create your tokens.");
                } else if (gameData.status === 'tokens_created' || gameData.status === 'token_picked') {
                    showPhase(gamePhase);
                    gamePhaseMessage.textContent = "Player 2's Turn: Waiting for a pick...";
                    pickTokenBtn.classList.add('hidden');

                    if (allTokensRevealed) {
                        gameOverMessage.classList.remove('hidden');
                        gamePhaseMessage.textContent = "Game Over!";
                        playAgainBtn.classList.remove('hidden');
                    } else if (revealedToken) {
                        revealedTokenContainer.classList.remove('hidden');
                        revealedTokenContent.textContent = revealedToken;
                    }
                }
            }
            // Player 2's flow
            else if (playerRole === 'player2') {
                if (gameData.status === 'waiting_for_player2' || gameData.status === 'ready_to_create_tokens') {
                    showPhase(waitingPhase);
                    waitingMessage.textContent = `Joined game ${gameId}! Waiting for Player 1 to create tokens...`;
                } else if (gameData.status === 'tokens_created' || gameData.status === 'token_picked') {
                    showPhase(gamePhase);
                    gamePhaseMessage.textContent = "Your Turn: Pick a token!";
                    pickTokenBtn.classList.add('hidden');

                    if (allTokensRevealed) {
                        gameOverMessage.classList.remove('hidden');
                        gamePhaseMessage.textContent = "Game Over! All tokens picked.";
                        playAgainBtn.classList.remove('hidden');
                        showMessage('All tokens picked! Reset to play again.', false);
                    } else if (revealedToken) {
                        revealedTokenContainer.classList.remove('hidden');
                        revealedTokenContent.textContent = revealedToken;
                    }
                }
            }
        }

        /**
         * Renders the individual token cards in the display area.
         * @param {Array<object>} currentTokens - The array of token objects from Firestore.
         */
        function renderTokenCards(currentTokens) {
            tokenDisplayArea.innerHTML = ''; // Clear existing cards

            if (!currentTokens || currentTokens.length === 0) {
                tokenDisplayArea.innerHTML = '<p class="text-gray-500">No tokens created yet.</p>';
                return;
            }

            currentTokens.forEach(token => {
                const card = document.createElement('div');
                card.classList.add('token-card-display');
                card.dataset.tokenId = token.id; // Store token ID for easy lookup

                const contentSpan = document.createElement('span');
                contentSpan.classList.add('token-content-text');

                if (token.revealed) {
                    card.classList.add('revealed');
                    contentSpan.textContent = token.content;
                    card.classList.add('disabled'); // Disable revealed cards
                } else {
                    contentSpan.textContent = '?'; // Hidden content
                    if (playerRole === 'player2') {
                        // Only Player 2 can click unrevealed tokens
                        card.addEventListener('click', () => pickSpecificToken(token.id));
                    } else {
                        // Player 1 cannot click, so disable interaction
                        card.classList.add('disabled');
                    }
                }

                // If a token was picked by someone else (Player 1 seeing Player 2's pick)
                // This condition applies if the token is NOT revealed yet, but HAS been picked by another user.
                if (token.pickedBy && token.pickedBy !== userId && !token.revealed) {
                    card.classList.add('picked'); // Style to show it was picked by other player
                    contentSpan.textContent = 'Picked!'; // Indicate it was picked
                    card.classList.add('disabled'); // Disable picked cards
                }

                card.appendChild(contentSpan);
                tokenDisplayArea.appendChild(card);
            });
        }


        /**
         * Generates the specified number of input fields for token content (Player 1).
         */
        function generateTokenInputFields() {
            const num = parseInt(numTokensInput.value, 10);

            if (isNaN(num) || num < 2) {
                showMessage('Please enter a number of tokens (minimum 2).', true);
                return;
            }

            numberOfTokensToGenerate = num;
            dynamicTokenInputs.innerHTML = ''; // Clear previous fields

            for (let i = 0; i < numberOfTokensToGenerate; i++) {
                const textarea = document.createElement('textarea');
                textarea.classList.add('input-field', 'token-text-input', 'handwriting-font');
                textarea.placeholder = `Enter text for Token ${i + 1}`;
                textarea.id = `tokenText_${i}`; // Unique ID for each textarea
                dynamicTokenInputs.appendChild(textarea);
            }

            showPhase(contentInputPhase);
            showMessage(`Generated ${numberOfTokensToGenerate} token input fields.`);
        }

        /**
         * Collects text from dynamic input fields and updates Firestore (Player 1).
         */
        async function confirmTokensAndStartGame() {
            if (!gameId || playerRole !== 'player1') {
                showMessage("You are not Player 1 or not in a game.", true);
                return;
            }

            const newTokens = [];
            let allFieldsFilled = true;

            for (let i = 0; i < numberOfTokensToGenerate; i++) {
                const textarea = document.getElementById(`tokenText_${i}`);
                if (textarea && textarea.value.trim() !== '') {
                    // Assign a unique ID to each token object
                    newTokens.push({
                        id: `token-${Date.now()}-${i}`, // Simple unique ID
                        content: textarea.value.trim(),
                        revealed: false,
                        pickedBy: null // Track who picked it, if anyone
                    });
                } else {
                    allFieldsFilled = false;
                    break;
                }
            }

            if (!allFieldsFilled) {
                showMessage('Please fill in text for all tokens before confirming.', true);
                return;
            }

            if (newTokens.length < 2) {
                showMessage('Something went wrong. Please ensure at least 2 tokens are entered.', true);
                return;
            }

            // Shuffle tokens before saving to Firestore
            for (let i = newTokens.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newTokens[i], newTokens[j]] = [newTokens[j], newTokens[i]];
            }

            tokens = newTokens; // Update local tokens array

            try {
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
                await updateDoc(gameRef, {
                    tokens: tokens,
                    status: 'tokens_created',
                    revealedToken: null,
                    lastUpdated: serverTimestamp()
                });
                showMessage('Tokens confirmed and saved! Player 2 can now pick.');
            } catch (error) {
                console.error("Error confirming tokens:", error);
                showMessage("Failed to save tokens. Please try again.", true);
            }
        }

        /**
         * Player 2 picks a specific token by its ID.
         * @param {string} tokenId - The ID of the token to pick.
         */
        async function pickSpecificToken(tokenId) {
            if (!gameId || playerRole !== 'player2') {
                showMessage("You are not Player 2 or not in a game.", true);
                return;
            }

            const tokenIndex = tokens.findIndex(t => t.id === tokenId);
            if (tokenIndex === -1) {
                showMessage('Selected token not found.', true);
                return;
            }

            if (tokens[tokenIndex].revealed) {
                showMessage('This token has already been revealed.', true);
                return;
            }

            const updatedTokens = [...tokens];
            updatedTokens[tokenIndex].revealed = true;
            updatedTokens[tokenIndex].pickedBy = userId; // Mark who picked it

            try {
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
                await updateDoc(gameRef, {
                    tokens: updatedTokens,
                    revealedToken: updatedTokens[tokenIndex].content, // Content of the specific picked token
                    status: 'token_picked',
                    lastUpdated: serverTimestamp()
                });
                showMessage('Token picked and revealed!');
            } catch (error) {
                console.error("Error picking token:", error);
                showMessage("Failed to pick token. Please try again.", true);
            }
        }

        /**
         * Resets the game to its initial state and clears Firestore data.
         * This performs a full reset, returning to the initial create/join screen.
         */
        async function resetGame() {
            if (unsubscribeFromGame) {
                unsubscribeFromGame();
            }

            if (gameId && playerRole === 'player1') {
                try {
                    // Only Player 1 should clear the game document for a full reset
                    await setDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), {
                        players: [{ id: userId, name: userName, role: 'player1' }], // Reset to just player 1
                        status: 'waiting_for_player2',
                        tokens: [],
                        revealedToken: null,
                        lastUpdated: serverTimestamp()
                    });
                    console.log("Game document reset by Player 1.");
                } catch (error) {
                    console.error("Error resetting game document:", error);
                }
            }

            tokens = [];
            revealedToken = null;
            numberOfTokensToGenerate = 0;
            playerRole = null;
            players = []; // Clear players array
            gameId = null;
            numTokensInput.value = 4;
            dynamicTokenInputs.innerHTML = '';
            revealedTokenContainer.classList.add('hidden');
            gameOverMessage.classList.add('hidden');
            playAgainBtn.classList.add('hidden');

            // Clear URL parameters
            const url = new URL(window.location.href);
            url.searchParams.delete('gameId');
            window.history.replaceState({}, document.title, url.toString());

            showPhase(usernameInputPhase); // Go back to username input
            updatePlayerIndicators(null);
            showMessage('Game reset. You can now create or join a new game!');
        }

        /**
         * Starts a new round of the game with the same players.
         * Only Player 1 can initiate this.
         */
        async function playAgain() {
            if (!gameId) {
                showMessage("No active game to replay.", true);
                return;
            }

            if (playerRole === 'player1') {
                try {
                    // Reset game state in Firestore for the current game ID
                    await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), {
                        tokens: [],
                        revealedToken: null,
                        status: 'ready_to_create_tokens', // Go back to token creation phase
                        lastUpdated: serverTimestamp()
                    });
                    showMessage("Starting a new round! Player 2, wait for new tokens.");
                    // UI will update via onSnapshot listener
                } catch (error) {
                    console.error("Error starting new round:", error);
                    showMessage("Failed to start new round. Please try again.", true);
                }
            } else if (playerRole === 'player2') {
                showMessage("Waiting for Player 1 to start a new round.", false);
            }
        }

        // Event Listeners
        continueBtn.addEventListener('click', handleUsernameInput);
        usernameInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleUsernameInput();
            }
        });

        createGameBtn.addEventListener('click', createGame);
        joinGameBtn.addEventListener('click', joinGame);
        generateTokenFieldsBtn.addEventListener('click', generateTokenInputFields);
        confirmTokensBtn.addEventListener('click', confirmTokensAndStartGame);
        playAgainBtn.addEventListener('click', playAgain);
        resetGameBtn.addEventListener('click', resetGame);

        numTokensInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                generateTokenFieldsBtn.click();
            }
        });

        gameIdInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                joinGameBtn.click();
            }
        });

        // Start by showing the username input phase
        window.onload = () => showPhase(usernameInputPhase);

    </script>
</body>
</html>
