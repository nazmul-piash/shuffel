<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Multiplayer Token Game</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter for general text, Caveat for handwriting -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Caveat:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); /* Softer shadow */
            padding: 2.5rem; /* More padding */
            max-width: 600px;
            width: 100%;
            text-align: center;
        }
        .btn-primary {
            background-color: #4f46e5; /* Indigo */
            color: white;
            padding: 0.8rem 1.8rem;
            border-radius: 0.75rem; /* Rounded corners for buttons */
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out;
            box-shadow: 0 4px 10px rgba(79, 70, 229, 0.3); /* Button shadow */
        }
        .btn-primary:hover {
            background-color: #4338ca; /* Darker indigo on hover */
            transform: translateY(-2px); /* Slight lift effect */
            box-shadow: 0 6px 15px rgba(79, 70, 229, 0.4);
        }
        .btn-primary:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(79, 70, 229, 0.3);
        }
        .btn-secondary {
            background-color: #6b7280; /* Gray */
            color: white;
            padding: 0.8rem 1.8rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out;
            box-shadow: 0 4px 10px rgba(107, 114, 128, 0.3);
        }
        .btn-secondary:hover {
            background-color: #4b5563; /* Darker gray on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(107, 114, 128, 0.4);
        }
        .btn-secondary:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(107, 114, 128, 0.3);
        }
        .input-field {
            border: 1px solid #d1d5db; /* Light gray border */
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            width: 100%;
            font-size: 1rem;
            color: #374151; /* Dark gray text */
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .input-field:focus {
            outline: none;
            border-color: #6366f1; /* Focus color */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); /* Focus ring */
        }
        .handwriting-font {
            font-family: 'Caveat', cursive;
            font-size: 1.5rem; /* Larger for readability */
        }
        .message-box {
            background-color: #d1fae5; /* Light green for success */
            border: 1px solid #34d399; /* Green border */
            color: #065f46; /* Dark green text */
            padding: 1rem;
            border-radius: 0.75rem;
            margin-top: 1.5rem;
            font-weight: 600;
            display: none; /* Hidden by default */
        }
        .message-box.error {
            background-color: #fee2e2; /* Light red for error */
            border-color: #ef4444; /* Red border */
            color: #991b1b; /* Dark red text */
        }
        /* Style for individual token input fields */
        .token-text-input {
            border: 1px solid #c7d2fe;
            border-radius: 0.75rem;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            width: 100%;
            box-sizing: border-box;
            resize: vertical; /* Allow vertical resizing */
            min-height: 50px; /* Minimum height for textarea */
        }
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #4f46e5;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .player-tag { /* New style for dynamic player tags */
            padding: 0.4rem 0.8rem;
            border-radius: 9999px; /* Fully rounded pill shape */
            font-weight: 600;
            font-size: 0.875rem; /* text-sm */
            background-color: #e0e7ff; /* Light indigo */
            color: #4f46e5; /* Indigo */
            border: 1px solid #c7d2fe;
            transition: all 0.2s ease-in-out;
        }
        .player-tag.current-user {
            background-color: #6366f1; /* Stronger indigo */
            color: white;
            border-color: #4f46e5;
            box-shadow: 0 2px 5px rgba(99, 102, 241, 0.3);
        }
        .token-card-display {
            background-color: #a5b4fc; /* Slightly darker indigo for folded state */
            color: #ffffff;
            font-size: 1.25rem; /* Larger font for '?' */
            font-weight: 700;
            width: 100px; /* Fixed width for consistent cards */
            height: 100px; /* Fixed height for consistent cards */
            border-radius: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0.5rem;
            box-shadow: 0 4px 10px rgba(79, 70, 229, 0.2);
            transition: all 0.3s ease-in-out;
            cursor: pointer;
            flex-shrink: 0; /* Prevent shrinking in flex container */
            position: relative; /* For overlay */
        }
        .token-card-display:hover:not(.revealed):not(.picked) {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px rgba(79, 70, 229, 0.3);
        }
        .token-card-display.revealed {
            background-color: #d1fae5; /* Light green for revealed */
            color: #065f46;
            cursor: default;
            box-shadow: 0 4px 10px rgba(52, 211, 153, 0.3);
            border: 2px solid #34d399;
        }
        .token-card-display.picked {
            background-color: #fca5a5; /* Light red for picked by other */
            color: #991b1b;
            cursor: default;
            box-shadow: 0 4px 10px rgba(239, 68, 68, 0.3);
            border: 2px solid #ef4444;
        }
        .token-card-display.disabled {
            opacity: 0.7;
            cursor: default;
            pointer-events: none; /* Disable clicks */
        }
        .game-over-message {
            color: #ef4444; /* Red for game over */
            font-size: 1.8rem;
            font-weight: 700;
            margin-top: 1.5rem;
        }
        .token-content-text {
            font-family: 'Caveat', cursive;
            font-size: 1.2rem;
            padding: 0.5rem;
            word-break: break-all;
            text-align: center;
        }
        /* Modal styles for player limit input */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 400px;
            text-align: center;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-5">
    <div class="container bg-white p-10 rounded-3xl shadow-xl flex flex-col items-center">
        <h1 class="text-4xl font-extrabold text-gray-800 mb-6">The Multiplayer Token Game</h1>
        <!-- User ID display, initially hidden -->
        <p id="userIdDisplay" class="text-sm text-gray-500 mb-4 break-all hidden">Your User ID: <span id="currentUserId" class="font-mono">Loading...</span></p>

        <!-- Dynamic Player List Display (replaces fixed Player 1/2 indicators) -->
        <div id="connectedPlayersList" class="flex flex-wrap justify-center gap-2 mb-6 w-full">
            <!-- Player tags will be dynamically inserted here -->
        </div>

        <!-- Username Input Phase -->
        <div id="username-input-phase" class="w-full">
            <p class="text-lg text-gray-600 mb-4">Enter your username to begin:</p>
            <input type="text" id="usernameInput" class="input-field mb-4" placeholder="Your Username (e.g., PlayerOne)">
            <button id="continueBtn" class="btn-primary w-full">Continue</button>
        </div>

        <!-- Initial Phase: Create or Join Game -->
        <div id="initial-phase" class="w-full hidden">
            <p class="text-lg text-gray-600 mb-4">Welcome, <span id="displayUsername" class="font-semibold text-indigo-700"></span>! What would you like to do?</p>
            <button id="createGameBtn" class="btn-primary w-full mb-4">Create New Game</button>
            <div class="flex items-center justify-center my-4">
                <span class="text-gray-500">OR</span>
            </div>
            <input type="text" id="gameIdInput" class="input-field mb-4" placeholder="Enter Game ID to Join">
            <button id="joinGameBtn" class="btn-secondary w-full">Join Game</button>
        </div>

        <!-- Waiting Phase (for Player 1 after creating game, or Player 2 after joining) -->
        <div id="waiting-phase" class="w-full hidden">
            <p class="text-lg text-gray-600 mb-4" id="waitingMessage">Waiting for other players...</p>
            <p id="gameIdDisplay" class="text-xl font-bold text-gray-800 mb-4 hidden">Game ID: <span id="currentShareGameId" class="font-mono"></span></p>
            <button id="shareGameIdBtn" class="btn-primary mb-4 hidden">Share Game ID</button>
            <div class="loading-spinner"></div>
        </div>

        <!-- Phase 1: Specify Number of Tokens (Host only) -->
        <div id="number-input-phase" class="w-full hidden">
            <p class="text-lg text-gray-600 mb-4">Host: How many tokens do you want?</p>
            <input type="number" id="numTokensInput" class="input-field mb-4" min="2" value="4" placeholder="Enter number of tokens (min 2)">
            <button id="generateTokenFieldsBtn" class="btn-primary w-full mb-6">Generate Token Fields</button>
        </div>

        <!-- Phase 2: Enter Token Content (Host only) -->
        <div id="content-input-phase" class="w-full hidden">
            <p class="text-lg text-gray-600 mb-4">Host: Enter text for each token.</p>
            <div id="dynamicTokenInputs" class="flex flex-col gap-3 mb-6">
                <!-- Dynamic token input fields will be appended here -->
            </div>
            <button id="confirmTokensBtn" class="btn-primary w-full mb-6">Confirm Tokens & Shuffle</button>
        </div>

        <!-- Phase 3: Pick Token -->
        <div id="game-phase" class="w-full hidden">
            <p class="text-lg text-gray-600 mb-6" id="gamePhaseMessage">Pick a token!</p>

            <!-- Display area for individual tokens -->
            <div id="tokenDisplayArea" class="flex flex-wrap justify-center gap-4 mb-6">
                <!-- Token cards will be rendered here -->
            </div>

            <div id="revealedTokenContainer" class="message-box hidden">
                <p class="text-xl font-bold mb-2">You got:</p>
                <p id="revealedTokenContent" class="text-2xl text-indigo-700 font-extrabold break-words handwriting-font"></p>
            </div>

            <p id="gameOverMessage" class="game-over-message hidden">Game Over! All tokens picked.</p>

            <!-- New "Play Again" button -->
            <button id="playAgainBtn" class="btn-primary w-full mb-4 hidden">Play Again</button>
            <!-- Original "Reset Game" button for full reset -->
            <button id="resetGameBtn" class="btn-secondary w-full mt-4">Reset Game</button>
        </div>

        <!-- Message Box for Feedback -->
        <div id="messageBox" class="message-box w-full hidden"></div>
    </div>

    <!-- Modal for Player Limit Input -->
    <div id="playerLimitModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-4">Set Player Limit</h2>
            <p class="text-md text-gray-700 mb-4">How many players will join this game?</p>
            <input type="number" id="maxPlayersInput" class="input-field mb-4" min="2" max="10" value="2">
            <button id="confirmPlayerLimitBtn" class="btn-primary w-full">Confirm</button>
        </div>
    </div>

    <script type="module">
        // Firebase imports
        // Corrected import for 'collection' from 'firebase/firestore'
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, collection, arrayUnion, arrayRemove, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js";

        // Firebase configuration from your Firebase project (provided by user)
        const firebaseConfig = {
            apiKey: "AIzaSyCz5NXK-P5FK-c8yh8oph2kgODB_cBoi1g",
            authDomain: "we-shuffle.firebaseapp.com",
            projectId: "we-shuffle",
            storageBucket: "we-shuffle.firebasestorage.app",
            messagingSenderId: "94132103590",
            appId: "1:94132103590:web:70f7ae80fe8c96dc664767",
            measurementId: "G-RGEF60JEKN"
        };

        // Derived from firebaseConfig
        const appId = firebaseConfig.appId;
        const initialAuthToken = null; // Not needed for anonymous sign-in in this context

        // Firebase App and Services
        let app, db, auth;
        let userId = null;
        let userName = null; // Global variable for username
        let gameId = null;
        let unsubscribeFromGame = null; // To store the Firestore snapshot listener unsubscribe function

        // Game state variables
        // Tokens: { id: string, content: string, revealed: boolean, pickedBy: string|null }
        let tokens = [];
        let revealedToken = null; // Content of the last revealed token
        let numberOfTokensToGenerate = 0;
        // playerRole will be 'host' or 'guest'
        let playerRole = null;
        // Players: [{id: userId, name: userName, isHost: boolean}, ...]
        let players = [];
        let maxPlayers = 2; // Default max players

        // Get DOM elements
        const usernameInputPhase = document.getElementById('username-input-phase');
        const usernameInput = document.getElementById('usernameInput');
        const continueBtn = document.getElementById('continueBtn');
        const displayUsername = document.getElementById('displayUsername');

        const userIdDisplay = document.getElementById('userIdDisplay');
        const currentUserIdSpan = document.getElementById('currentUserId');
        const connectedPlayersList = document.getElementById('connectedPlayersList'); // New element for dynamic player list

        const initialPhase = document.getElementById('initial-phase');
        const createGameBtn = document.getElementById('createGameBtn');
        const gameIdInput = document.getElementById('gameIdInput');
        const joinGameBtn = document.getElementById('joinGameBtn');
        const waitingPhase = document.getElementById('waiting-phase');
        const waitingMessage = document.getElementById('waitingMessage');
        const gameIdDisplay = document.getElementById('gameIdDisplay'); // To show game ID in waiting phase
        const currentShareGameId = document.getElementById('currentShareGameId'); // Span for the game ID
        const shareGameIdBtn = document.getElementById('shareGameIdBtn'); // Share button

        const numberInputPhase = document.getElementById('number-input-phase');
        const numTokensInput = document.getElementById('numTokensInput');
        const generateTokenFieldsBtn = document.getElementById('generateTokenFieldsBtn');
        const contentInputPhase = document.getElementById('content-input-phase');
        const confirmTokensBtn = document.getElementById('confirmTokensBtn');
        const dynamicTokenInputs = document.getElementById('dynamicTokenInputs');
        const gamePhase = document.getElementById('game-phase');
        const gamePhaseMessage = document.getElementById('gamePhaseMessage');
        const tokenDisplayArea = document.getElementById('tokenDisplayArea');
        const pickTokenBtn = document.getElementById('pickTokenBtn');
        const revealedTokenContainer = document.getElementById('revealedTokenContainer');
        const revealedTokenContent = document.getElementById('revealedTokenContent');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const resetGameBtn = document.getElementById('resetGameBtn');
        const messageBox = document.getElementById('messageBox');

        // Modal elements
        const playerLimitModal = document.getElementById('playerLimitModal');
        const maxPlayersInput = document.getElementById('maxPlayersInput');
        const confirmPlayerLimitBtn = document.getElementById('confirmPlayerLimitBtn');

        /**
         * Displays a message in the message box.
         * @param {string} message - The message to display.
         * @param {boolean} isError - True if it's an error message, false otherwise.
         */
        function showMessage(message, isError = false) {
            messageBox.textContent = message;
            messageBox.classList.remove('hidden', 'error');
            if (isError) {
                messageBox.classList.add('error');
            }
            messageBox.classList.remove('hidden');
            // Hide message after 3 seconds
            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 3000);
        }

        /**
         * Hides all game phases and shows only the specified one.
         * @param {HTMLElement} phaseToShow - The phase element to display.
         */
        function showPhase(phaseToShow) {
            usernameInputPhase.classList.add('hidden');
            initialPhase.classList.add('hidden');
            waitingPhase.classList.add('hidden');
            numberInputPhase.classList.add('hidden');
            contentInputPhase.classList.add('hidden');
            gamePhase.classList.add('hidden');
            playAgainBtn.classList.add('hidden');
            gameOverMessage.classList.add('hidden');
            revealedTokenContainer.classList.add('hidden');
            gameIdDisplay.classList.add('hidden'); // Hide game ID display by default
            shareGameIdBtn.classList.add('hidden'); // Hide share button by default
            playerLimitModal.classList.add('hidden'); // Hide modal by default
            phaseToShow.classList.remove('hidden');
        }

        /**
         * Updates the dynamic player list.
         */
        function updateConnectedPlayersList() {
            connectedPlayersList.innerHTML = ''; // Clear existing tags
            if (players.length === 0) {
                connectedPlayersList.innerHTML = '<p class="text-gray-500 text-sm">No players connected yet.</p>';
                return;
            }

            players.forEach(player => {
                const playerTag = document.createElement('div');
                playerTag.classList.add('player-tag');
                playerTag.textContent = player.name;
                if (player.id === userId) {
                    playerTag.classList.add('current-user');
                }
                connectedPlayersList.appendChild(playerTag);
            });
        }

        /**
         * Initializes Firebase and authenticates the user.
         * Now called after username is entered.
         */
        async function initializeFirebaseAndAuthenticate() {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        currentUserIdSpan.textContent = userId;
                        console.log("Authenticated with user ID:", userId);

                        displayUsername.textContent = userName;
                        showPhase(initialPhase);

                        const urlParams = new URLSearchParams(window.location.search);
                        const urlGameId = urlParams.get('gameId');
                        if (urlGameId) {
                            gameIdInput.value = urlGameId;
                            joinGame();
                        } else {
                            updateConnectedPlayersList(); // Initial render of player list (only current user)
                        }
                    } else {
                        currentUserIdSpan.textContent = 'Not Authenticated';
                        console.log("No user is signed in.");
                        showMessage("Authentication failed. Please refresh.", true);
                    }
                });
            } catch (error) {
                console.error("Error initializing Firebase or authenticating:", error);
                showMessage("Failed to initialize game. Please try again later.", true);
            }
        }

        /**
         * Handles username input and proceeds to authentication.
         */
        function handleUsernameInput() {
            const inputName = usernameInput.value.trim();
            if (inputName.length < 2) {
                showMessage("Please enter a username (at least 2 characters).", true);
                return;
            }
            userName = inputName;
            initializeFirebaseAndAuthenticate();
        }

        /**
         * Prompts Player 1 for the number of players.
         */
        function promptForPlayerLimit() {
            showPhase(playerLimitModal); // Show the modal
            maxPlayersInput.value = 2; // Reset to default
        }

        /**
         * Creates a new game session in Firestore.
         */
        async function createGame() {
            if (!userId || !userName) {
                showMessage("User not authenticated or username missing. Please wait.", true);
                return;
            }

            // Show modal to get maxPlayers
            promptForPlayerLimit();
        }

        /**
         * Confirms player limit and proceeds to create the game.
         */
        async function confirmPlayerLimitAndCreateGame() {
            const limit = parseInt(maxPlayersInput.value, 10);
            if (isNaN(limit) || limit < 2 || limit > 10) {
                showMessage("Please enter a valid number of players between 2 and 10.", true);
                return;
            }
            maxPlayers = limit; // Set global maxPlayers
            showPhase(waitingPhase); // Hide modal and show waiting phase
            waitingMessage.textContent = "Creating game...";

            try {
                const gamesCollectionRef = collection(db, `artifacts/${appId}/public/data/games`);
                const newGameRef = doc(gamesCollectionRef);
                gameId = newGameRef.id;

                // Host is the first player, and isHost is true
                players = [{ id: userId, name: userName, isHost: true }];

                await setDoc(newGameRef, {
                    players: players,
                    status: 'waiting_for_players', // More generic status
                    maxPlayers: maxPlayers, // Store max players
                    tokens: [],
                    revealedToken: null,
                    createdAt: serverTimestamp(),
                    lastUpdated: serverTimestamp()
                });

                // Set playerRole for the host
                playerRole = 'host';

                gameIdDisplay.classList.remove('hidden'); // Show game ID container
                currentShareGameId.textContent = gameId; // Display only the ID
                shareGameIdBtn.classList.remove('hidden'); // Show share button

                waitingMessage.textContent = `Game created! Share this Game ID with others:`;
                showMessage("Game created successfully!");

                listenToGameChanges();

            } catch (error) {
                console.error("Error creating game:", error);
                showMessage("Failed to create game. Please try again.", true);
                showPhase(initialPhase);
            }
        }


        /**
         * Joins an existing game session.
         */
        async function joinGame() {
            if (!userId || !userName) {
                showMessage("User not authenticated or username missing. Please wait.", true);
                return;
            }

            const inputGameId = gameIdInput.value.trim();
            if (!inputGameId) {
                showMessage("Please enter a Game ID to join.", true);
                return;
            }

            try {
                showPhase(waitingPhase);
                waitingMessage.textContent = "Joining game...";
                gameIdDisplay.classList.add('hidden'); // Hide game ID display
                shareGameIdBtn.classList.add('hidden'); // Hide share button

                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, inputGameId);
                const gameSnap = await getDoc(gameRef);

                if (!gameSnap.exists()) {
                    showMessage("Game not found. Please check the Game ID.", true);
                    showPhase(initialPhase);
                    return;
                }

                const gameData = gameSnap.data();
                maxPlayers = gameData.maxPlayers || 2; // Get maxPlayers from game data

                // Check if already in game
                if (gameData.players && gameData.players.some(p => p.id === userId)) {
                    gameId = inputGameId;
                    players = gameData.players;
                    playerRole = players.find(p => p.id === userId).isHost ? 'host' : 'guest';
                    showMessage(`Rejoined game ${gameId} as ${userName}.`);
                    listenToGameChanges();
                    return;
                }

                // Check if game is full
                if (gameData.players.length >= maxPlayers) {
                    showMessage("This game is already full.", true);
                    showPhase(initialPhase);
                    return;
                }

                // Add current user as a guest
                playerRole = 'guest';
                await updateDoc(gameRef, {
                    players: arrayUnion({ id: userId, name: userName, isHost: false }),
                    lastUpdated: serverTimestamp()
                });

                gameId = inputGameId;
                waitingMessage.textContent = `Joined game ${gameId}! Waiting for host to start...`;
                showMessage("Successfully joined game!");

                listenToGameChanges();

            } catch (error) {
                console.error("Error joining game:", error);
                showMessage("Failed to join game. Please try again.", true);
                showPhase(initialPhase);
            }
        }

        /**
         * Sets up a real-time listener for the current game document.
         */
        function listenToGameChanges() {
            if (unsubscribeFromGame) {
                unsubscribeFromGame();
            }

            if (!gameId) {
                console.error("Cannot listen to game changes: gameId is null.");
                return;
            }

            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            unsubscribeFromGame = onSnapshot(gameRef, (docSnap) => {
                if (docSnap.exists()) {
                    const gameData = docSnap.data();
                    players = gameData.players || []; // Update local players array
                    maxPlayers = gameData.maxPlayers || 2; // Ensure maxPlayers is updated
                    console.log("Game state updated:", gameData);
                    updateUIBasedOnGameState(gameData);
                } else {
                    showMessage("Game ended or deleted. Resetting...", true);
                    resetGame();
                }
            }, (error) => {
                console.error("Error listening to game changes:", error);
                showMessage("Lost connection to game. Please reset.", true);
            });
        }

        /**
         * Updates the UI based on the current game state from Firestore.
         * @param {object} gameData - The current game data from Firestore.
         */
        function updateUIBasedOnGameState(gameData) {
            tokens = gameData.tokens || [];
            revealedToken = gameData.revealedToken;

            updateConnectedPlayersList(); // Always update dynamic player list

            gameOverMessage.classList.add('hidden');
            revealedTokenContainer.classList.add('hidden');
            playAgainBtn.classList.add('hidden');

            renderTokenCards(tokens);

            const allTokensRevealed = tokens.length > 0 && tokens.every(token => token.revealed);
            const isHost = players.some(p => p.id === userId && p.isHost);
            const gameIsFull = players.length === maxPlayers;

            // Determine current user's role if not already set (e.g., after rejoining)
            if (!playerRole) {
                playerRole = isHost ? 'host' : 'guest';
            }

            // Host's flow
            if (playerRole === 'host') {
                if (gameData.status === 'waiting_for_players' && !gameIsFull) {
                    showPhase(waitingPhase);
                    waitingMessage.textContent = `Waiting for ${maxPlayers - players.length} more player(s) to join...`;
                    gameIdDisplay.classList.remove('hidden');
                    currentShareGameId.textContent = gameId;
                    shareGameIdBtn.classList.remove('hidden');
                } else if (gameData.status === 'waiting_for_players' && gameIsFull) {
                    // All players joined, host can now create tokens
                    showPhase(numberInputPhase);
                    showMessage("All players joined! Please create your tokens.");
                    // Update game status in Firestore to ready_to_create_tokens
                    if (gameData.status !== 'ready_to_create_tokens') {
                         updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), {
                            status: 'ready_to_create_tokens',
                            lastUpdated: serverTimestamp()
                        }).catch(e => console.error("Error updating status to ready_to_create_tokens:", e));
                    }
                }
                else if (gameData.status === 'ready_to_create_tokens' && gameIsFull && tokens.length === 0) {
                    showPhase(numberInputPhase); // Host still needs to create tokens
                }
                else if (gameData.status === 'tokens_created' || gameData.status === 'token_picked') {
                    showPhase(gamePhase);
                    gamePhaseMessage.textContent = "Waiting for players to pick tokens...";

                    if (allTokensRevealed) {
                        gameOverMessage.classList.remove('hidden');
                        gamePhaseMessage.textContent = "Game Over!";
                        playAgainBtn.classList.remove('hidden');
                    } else if (revealedToken) {
                        revealedTokenContainer.classList.remove('hidden');
                        revealedTokenContent.textContent = revealedToken;
                    }
                }
            }
            // Guest's flow
            else if (playerRole === 'guest') {
                if (gameData.status === 'waiting_for_players' && !gameIsFull) {
                    showPhase(waitingPhase);
                    waitingMessage.textContent = `Joined game ${gameId}! Waiting for ${maxPlayers - players.length} more player(s) to join...`;
                } else if (gameData.status === 'waiting_for_players' && gameIsFull) {
                    // All players joined, waiting for host to create tokens
                    showPhase(waitingPhase);
                    waitingMessage.textContent = `All players joined! Waiting for host to create tokens...`;
                }
                else if (gameData.status === 'ready_to_create_tokens' && gameIsFull && tokens.length === 0) {
                    showPhase(waitingPhase);
                    waitingMessage.textContent = `Host is creating tokens...`;
                }
                else if (gameData.status === 'tokens_created' || gameData.status === 'token_picked') {
                    showPhase(gamePhase);
                    gamePhaseMessage.textContent = "Your Turn: Pick a token!";

                    if (allTokensRevealed) {
                        gameOverMessage.classList.remove('hidden');
                        gamePhaseMessage.textContent = "Game Over! All tokens picked.";
                        playAgainBtn.classList.remove('hidden');
                        showMessage('All tokens picked! Reset to play again.', false);
                    } else if (revealedToken) {
                        revealedTokenContainer.classList.remove('hidden');
                        revealedTokenContent.textContent = revealedToken;
                    }
                }
            }
        }

        /**
         * Renders the individual token cards in the display area.
         * @param {Array<object>} currentTokens - The array of token objects from Firestore.
         */
        function renderTokenCards(currentTokens) {
            tokenDisplayArea.innerHTML = ''; // Clear existing cards

            if (!currentTokens || currentTokens.length === 0) {
                tokenDisplayArea.innerHTML = '<p class="text-gray-500">No tokens created yet.</p>';
                return;
            }

            currentTokens.forEach(token => {
                const card = document.createElement('div');
                card.classList.add('token-card-display');
                card.dataset.tokenId = token.id; // Store token ID for easy lookup

                const contentSpan = document.createElement('span');
                contentSpan.classList.add('token-content-text');

                if (token.revealed) {
                    card.classList.add('revealed');
                    contentSpan.textContent = token.content;
                    card.classList.add('disabled'); // Disable revealed cards
                } else {
                    contentSpan.textContent = '?'; // Hidden content
                    // Only allow guests to click unrevealed tokens
                    if (playerRole === 'guest') {
                        card.addEventListener('click', () => pickSpecificToken(token.id));
                    } else {
                        card.classList.add('disabled'); // Disable for host
                    }
                }

                // If a token was picked by someone else (Host seeing Guest's pick)
                if (token.pickedBy && token.pickedBy !== userId && !token.revealed) {
                    card.classList.add('picked');
                    contentSpan.textContent = 'Picked!';
                    card.classList.add('disabled');
                }

                card.appendChild(contentSpan);
                tokenDisplayArea.appendChild(card);
            });
        }


        /**
         * Generates the specified number of input fields for token content (Host only).
         */
        function generateTokenInputFields() {
            const num = parseInt(numTokensInput.value, 10);

            if (isNaN(num) || num < 2) {
                showMessage('Please enter a number of tokens (minimum 2).', true);
                return;
            }

            numberOfTokensToGenerate = num;
            dynamicTokenInputs.innerHTML = ''; // Clear previous fields

            for (let i = 0; i < numberOfTokensToGenerate; i++) {
                const textarea = document.createElement('textarea');
                textarea.classList.add('input-field', 'token-text-input', 'handwriting-font');
                textarea.placeholder = `Enter text for Token ${i + 1}`;
                textarea.id = `tokenText_${i}`; // Unique ID for each textarea
                dynamicTokenInputs.appendChild(textarea);
            }

            showPhase(contentInputPhase);
            showMessage(`Generated ${numberOfTokensToGenerate} token input fields.`);
        }

        /**
         * Collects text from dynamic input fields and updates Firestore (Host only).
         */
        async function confirmTokensAndStartGame() {
            if (!gameId || playerRole !== 'host') {
                showMessage("You are not the host or not in a game.", true);
                return;
            }

            const newTokens = [];
            let allFieldsFilled = true;

            for (let i = 0; i < numberOfTokensToGenerate; i++) {
                const textarea = document.getElementById(`tokenText_${i}`);
                if (textarea && textarea.value.trim() !== '') {
                    newTokens.push({
                        id: `token-${Date.now()}-${i}`,
                        content: textarea.value.trim(),
                        revealed: false,
                        pickedBy: null
                    });
                } else {
                    allFieldsFilled = false;
                    break;
                }
            }

            if (!allFieldsFilled) {
                showMessage('Please fill in text for all tokens before confirming.', true);
                return;
            }

            if (newTokens.length < 2) {
                showMessage('Something went wrong. Please ensure at least 2 tokens are entered.', true);
                return;
            }

            // Shuffle tokens before saving to Firestore
            for (let i = newTokens.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newTokens[i], newTokens[j]] = [newTokens[j], newTokens[i]];
            }

            tokens = newTokens; // Update local tokens array

            try {
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
                await updateDoc(gameRef, {
                    tokens: tokens,
                    status: 'tokens_created',
                    revealedToken: null,
                    lastUpdated: serverTimestamp()
                });
                showMessage('Tokens confirmed and saved! Players can now pick.');
            } catch (error) {
                console.error("Error confirming tokens:", error);
                showMessage("Failed to save tokens. Please try again.", true);
            }
        }

        /**
         * A guest player picks a specific token by its ID.
         * @param {string} tokenId - The ID of the token to pick.
         */
        async function pickSpecificToken(tokenId) {
            if (!gameId || playerRole !== 'guest') {
                showMessage("You are not a guest player or not in a game.", true);
                return;
            }

            const tokenIndex = tokens.findIndex(t => t.id === tokenId);
            if (tokenIndex === -1) {
                showMessage('Selected token not found.', true);
                return;
            }

            if (tokens[tokenIndex].revealed) {
                showMessage('This token has already been revealed.', true);
                return;
            }

            const updatedTokens = [...tokens];
            updatedTokens[tokenIndex].revealed = true;
            updatedTokens[tokenIndex].pickedBy = userId; // Mark who picked it

            try {
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
                await updateDoc(gameRef, {
                    tokens: updatedTokens,
                    revealedToken: updatedTokens[tokenIndex].content,
                    status: 'token_picked',
                    lastUpdated: serverTimestamp()
                });
                showMessage('Token picked and revealed!');
            } catch (error) {
                console.error("Error picking token:", error);
                showMessage("Failed to pick token. Please try again.", true);
            }
        }

        /**
         * Resets the game to its initial state and clears Firestore data.
         * This performs a full reset, returning to the initial create/join screen.
         * Only the host can fully reset the game document.
         */
        async function resetGame() {
            if (unsubscribeFromGame) {
                unsubscribeFromGame();
            }

            if (gameId && playerRole === 'host') {
                try {
                    // Host clears the game document, retaining themselves as the host
                    await setDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), {
                        players: [{ id: userId, name: userName, isHost: true }],
                        status: 'waiting_for_players',
                        maxPlayers: maxPlayers, // Keep the same max players for next round
                        tokens: [],
                        revealedToken: null,
                        lastUpdated: serverTimestamp()
                    });
                    console.log("Game document reset by host.");
                } catch (error) {
                    console.error("Error resetting game document:", error);
                }
            } else if (gameId && playerRole === 'guest') {
                 // Guests simply leave the game document
                try {
                    await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), {
                        players: arrayRemove({ id: userId, name: userName, isHost: false }),
                        lastUpdated: serverTimestamp()
                    });
                    console.log("Guest left the game.");
                } catch (error) {
                    console.error("Error leaving game:", error);
                }
            }


            tokens = [];
            revealedToken = null;
            numberOfTokensToGenerate = 0;
            playerRole = null;
            players = [];
            gameId = null;
            numTokensInput.value = 4;
            dynamicTokenInputs.innerHTML = '';
            revealedTokenContainer.classList.add('hidden');
            gameOverMessage.classList.add('hidden');
            playAgainBtn.classList.add('hidden');
            gameIdDisplay.classList.add('hidden'); // Hide game ID display
            shareGameIdBtn.classList.add('hidden'); // Hide share button

            // Clear URL parameters
            const url = new URL(window.location.href);
            url.searchParams.delete('gameId');
            window.history.replaceState({}, document.title, url.toString());

            showPhase(usernameInputPhase);
            updateConnectedPlayersList(); // Clear player list display
            showMessage('Game reset. You can now create or join a new game!');
        }

        /**
         * Starts a new round of the game with the same players.
         * Only the host can initiate this.
         */
        async function playAgain() {
            if (!gameId) {
                showMessage("No active game to replay.", true);
                return;
            }

            if (playerRole === 'host') {
                try {
                    // Reset game state in Firestore for the current game ID
                    await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), {
                        tokens: [],
                        revealedToken: null,
                        status: 'ready_to_create_tokens', // Go back to token creation phase
                        lastUpdated: serverTimestamp()
                    });
                    showMessage("Starting a new round! Other players, wait for new tokens.");
                } catch (error) {
                    console.error("Error starting new round:", error);
                    showMessage("Failed to start new round. Please try again.", true);
                }
            } else if (playerRole === 'guest') {
                showMessage("Waiting for the host to start a new round.", false);
            }
        }

        /**
         * Shares the game ID using the Web Share API if available.
         */
        async function shareGameId() {
            if (navigator.share) {
                try {
                    await navigator.share({
                        title: 'Join my Token Game!',
                        text: `Join my Multiplayer Token Game! Use this Game ID: ${gameId}`,
                        url: window.location.origin + window.location.pathname + `?gameId=${gameId}`
                    });
                    showMessage('Game ID shared successfully!');
                } catch (error) {
                    console.error('Error sharing:', error);
                    showMessage('Failed to share Game ID.', true);
                }
            } else {
                // Fallback for browsers that don't support Web Share API
                const dummyInput = document.createElement('input');
                document.body.appendChild(dummyInput);
                dummyInput.value = gameId;
                dummyInput.select();
                document.execCommand('copy');
                document.body.removeChild(dummyInput);
                showMessage('Game ID copied to clipboard! Share it manually.');
            }
        }


        // Event Listeners
        continueBtn.addEventListener('click', handleUsernameInput);
        usernameInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleUsernameInput();
            }
        });

        createGameBtn.addEventListener('click', createGame); // This now calls promptForPlayerLimit
        confirmPlayerLimitBtn.addEventListener('click', confirmPlayerLimitAndCreateGame); // New listener for modal
        maxPlayersInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                confirmPlayerLimitAndCreateGame();
            }
        });

        joinGameBtn.addEventListener('click', joinGame);
        generateTokenFieldsBtn.addEventListener('click', generateTokenInputFields);
        confirmTokensBtn.addEventListener('click', confirmTokensAndStartGame);
        playAgainBtn.addEventListener('click', playAgain);
        resetGameBtn.addEventListener('click', resetGame);
        shareGameIdBtn.addEventListener('click', shareGameId); // New share button listener

        numTokensInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                generateTokenFieldsBtn.click();
            }
        });

        gameIdInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                joinGameBtn.click();
            }
        });

        // Start by showing the username input phase
        window.onload = () => showPhase(usernameInputPhase);

    </script>
</body>
</html>
